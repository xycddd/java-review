1. 为什么AQS使用的是双向队列?使用AQS实现可重入锁？<br>
队列中的线程被取消之后被设置成空值，所以队列中遇到空值并不一定代表到达了队列的末尾，使用双向链表可以进行双重检查,从前向后扫描一次
，然后从后向前扫描一次，快速判断当前这个请求是否还在同步队列中<br>
https://blog.csdn.net/zhang5476499/article/details/83796289
2. hashmap使用什么方法解决冲突？使用头插法还是尾插法？头插有什么问题？那为什么还要在1.7的时候使用头插法？为什么头插换成尾插？
hashMap在jdK1.8之前采用的头插法，1.8版本以及之后的版本采用的是尾插法<br>
使用头插法在高并发场景下会造成链表成环的问题<br>
解决死循环是一个点还有一个点就是 当时1.7时候用头插是考虑到了一个所谓的热点数据的点(新插入的数据可能会更早用到)，但这其实是个伪命题,y因为JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置(就是因为头插) 所以最后的结果 还是打乱了插入的顺序 所以总的来看支撑1.7使用头插的这点原因也不足以支撑下去了 所以就干脆换成尾插 一举多得<br>
来自https://blog.csdn.net/qq_33256688/article/details/79938886
4. https://www.cnblogs.com/gxyandwmm/p/9495923.html
5. spring如何实现单例模式，哪些情况下会用到多例？
spring的三级缓存，实际上就是放到一个map中，用的时候去map中去取，有的话就取出来，没有就创建<br>
个人只在spring和struct2整合的时候用到多例
6. spring如何实现循环依赖?
Spring中有三级缓存<br>
singletonObjects 用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用 <br>
earlySingletonObjects 存放原始的 bean 对象（尚未填充属性），用于解决循环依赖 <br>
singletonFactories 存放 bean 工厂对象，用于解决循环依赖<br>

Spring的单例对象的初始化主要分为三步：<br>
（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象<br>
（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充<br>
（3）initializeBean：调用spring xml中的init 方法。<br>

实例化对象A的步骤，<br>
第一步，实例化，把自己添加到singletonFactories <br>
第二步，填充属性的时候发现需要B的引用，转而就是实例化B<br>

当实例化对象B的时候。调用对象的构造方法实例化对象，<br>
其次，填充属性，由于A把自己的引用添加到了singletonFactories (暴露给外部)，所以B直接拿到了A的引用，同时singletonFactories 将A的这个引用删除，添加到earlySingletonObjects 中，<br>
然后B调用init方法初始化自己。<br>

当B初始化完成之后，A填充关于B的属性，然后init，循环依赖决绝。因为B里面拿到的是A的引用，所以A初始化完成之后，B里面关于A的对象的填充也完成了。<br>
7. 为什么无法解决构造器循环依赖
因为在第一步实例化的时候需要调用构造器方法，加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决<br>
8. TCP报文段结构<br>
https://www.cnblogs.com/feng9exe/p/8058891.html<br>
9. Java中什么样的对象才能作为gc root，gc roots有哪些<br>
https://blog.csdn.net/yulidrff/article/details/85330045
10. mysql中的一些参数
```
<!--    连接池启动时的初始值 -->
<property name="initialSize" value="${initialSize}" />
<!--  连接池的最大值 -->
<property name="maxActive" value="${maxActive}"/>
<!-- 最大空闲值.当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 -->
<property name="maxIdle" value="${maxIdle}"/>
<!--   最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 -->
```
11. 进程调度算法<br>
https://www.cnblogs.com/szitcast/p/10927375.html<br>
https://blog.csdn.net/zh13487/article/details/83928284<br>
12. HTTP报文结构<br>
13. 什么时候使用聚簇索引？什么时候使用非聚簇索引？为什么频繁被修改的列使用非聚簇索引？
https://blog.csdn.net/qq_35956041/article/details/81017995<br>
最通俗的解释是:聚簇索引的顺序就是数据的物理存储顺序，而对非聚簇索引的索引顺序与数据物理排列顺序无关。举例来说，你翻到新华字典的汉字“爬”那一页就是P开头的部分，这就是物理存储顺序（聚簇索引）；而不用你到目录，找到汉字“爬”所在的页码，然后根据页码找到这个字（非聚簇索引
14. springboot自动配置原理<br>
https://blog.csdn.net/u014745069/article/details/83820511<br>
15. react和Vue的区别<br>
https://www.jianshu.com/p/b7cd52868e95?from=groupmessage
16. await/async和Promise的区别<br>
简洁<br>
try/catch能够处理同步和异步的错误，promise的try/catch不能需要.catch
避免深层的嵌套<br>
17. linux的五种IO模型<br>
https://www.jianshu.com/p/e4768446f7eb<br>
https://blog.csdn.net/historyasamirror/article/details/5778378<br>
https://www.cnblogs.com/cyanjng/p/9828092.html<br>
18. 超线程和多线程的区别<br>
https://blog.csdn.net/cheng__lu/article/details/98884263<br>
20. 守护线程和用户线程的区别<br>
https://blog.csdn.net/weixin_39935887/article/details/80623769<br>
21. 缓存一致性协议<br>
https://www.cnblogs.com/yjf512/p/5166415.html
22. CPU二级缓存为什么要这样设计？<br>
CPU的局部性原理<br>
23. Tomcat 类加载器之为何违背双亲委派模型？<br>
https://blog.csdn.net/qq_38182963/article/details/78660779<br>
24. Tom的消息处理过程<br>
https://www.cnblogs.com/haimishasha/p/10744696.html<br>
https://www.cnblogs.com/haimishasha/p/10747901.html<br>
25. IOm模式中的Proactor和Reactor区别<br>
1、 Reactor被动的等待指示事件的到来并作出反应，有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作，实现相对简单，对于耗时短的处理场景比较高效，但Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理。<br>
2、Proactor直接调用异步读写操作，调用完后立刻返回，实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响），Proactor性能更高，能够处理耗时长的并发场景，但Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现。<br>
https://segmentfault.com/a/1190000002715832<br>
26. zookeeper常见问题<br>
https://blog.csdn.net/yjp198713/article/details/79400927<br>
https://segmentfault.com/a/1190000014479433<br>
https://blog.csdn.net/Sunshine_2211468152/article/details/87938175<br>
27. Integer的底层原理<br>
https://www.cnblogs.com/vinozly/p/5173477.html<br>
28. elasticSearch常见经典面试题<br>
https://blog.csdn.net/cx521600/article/details/90231707<br>
29. 什么是js闭包？<br>
https://www.cnblogs.com/Renyi-Fan/p/11590231.html<br>
30. mybatis常见面试题<br>
https://blog.csdn.net/a745233700/article/details/80977133<br>
https://blog.csdn.net/wchengsheng/article/details/79926977?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task<br>
https://blog.csdn.net/fxkcsdn/article/details/82466762?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task<br>
31. mybatis执行sql语句的流程<br>
https://www.cnblogs.com/dongying/p/4142476.html<br>
32. token和jwttoken的区别<br>
https://blog.csdn.net/m19123456789/article/details/85010509<br>
33. jwt常见面试题<br>
https://blog.csdn.net/MINGJU2020/article/details/103039418<br>
https://blog.csdn.net/a1098766713/article/details/102914354<br>
34. cpu为什么有多级缓存<br>
cpu的局部性原理<br>
35. ping用到的协议？ICMP<br>
https://blog.csdn.net/ty13572053785/article/details/85265062<br>
https://blog.csdn.net/baidu_37964071/article/details/80514340<br>
https://www.jianshu.com/p/e7bb22b8fd0a<br>
36. JDK中享元模式和原型模式的应用<br>
享元模式：string常量池，数据库连接池<br>
原型模式：object的clone方法，不执行构造函数，Object类的clone()方法的原理是从堆内存中以二进制流的方式进行拷贝，重新分配一个内存块，所以对象拷贝时构造函数不会被执行<br>
https://www.cnblogs.com/fengyumeng/p/10646487.html<br>
https://www.cnblogs.com/adamjwh/p/9070107.html<br>
https://blog.csdn.net/qq_40378034/article/details/104101065<br>
37. git和svn的区别<br>
https://blog.csdn.net/qq_40143330/article/details/79816024<br>
https://www.jianshu.com/p/bfec042349ca<br>
38. socket和websocket<br>
https://blog.csdn.net/Joven0/article/details/104694132/<br>
39. 并发编程下lock的四个函数的区别<br>
https://www.cnblogs.com/dolphin0520/p/3923167.html<br>
40. spring session原理简单说明:
(1)先要将SessionRepositoryFilter和JedisConnectionFactory进行注册 （结合spring bean的生命周期去理解）<br>
最开始的时候,加载了xml配置文件，并初始化web应用上下文，然后到application-session.xml中，配置 RedisHttpSessionConfiguration的bean和JedisConnectionFactory的bean，然后实例化它们，填充相关属性，由于RedisHttpSessionConfiguration实现了importAware接口，因此要调用相应的set
方法，之后调用相应的初始化方法对它们进行初始化<br>
(2)先要将sessionRepositoryFilter添加到拦截器链中<br>
首先，ServletContainerInitializer中可以定制哪些类需要加载，通过注解@HandlesTypes(WebApplicationInitializer.class)，让Servlet容器在启动该类时，会自动寻找所有的WebApplicationInitializer实现类。之后调用onStartUp的方法，onStartup方法里面有一个insertSessionRepositoryFilter，insertSessionRepositoryFilter内部有一个DelegatingFilterProxy ，就是我们在web.xml中配置的springSessionRepositoryFilter,通过这个代理生成springSessionRepositoryFilter，然后调用registerFilter将springSessionRepositoryFilter注册进去，registerFilter调用addFilter将Filter添加到拦截器链中<br>
(3)请求拦截过程<br>
请求被DelegatingFilterProxy : 拦截到，然后执行doFilter方法，在doFilter中找到执行的代理类。<br>
OncePerRequestFilter : 代理Filter执行doFilter方法，然后调用抽象方法doFilterInternal<br>
SessionRepositoryFilter 继承了OncePerRequestFilter，实现了doFilterInternal，这个方法一个封装一个wrappedRequest，通过执行commitSession保存session信息到redis<br>
(4)commitSession操作<br>
提交session保存,获取当前session，这一步比较重要，获取了一个HttpSessionWrapper，这个HttpSessionWrapper替换了HTTPSession，wrappedSession获取当前的Session，使用 RedisTemplate 保存Session内容，并通过调用RedisConnection 使用它的实现类JedisClusterConnection获取redis连接
https://blog.csdn.net/u010648555/article/details/79491988<br>
https://blog.csdn.net/u012881904/article/details/78827434<br>
41. spring cloud序列化方式？<br>
json序列化<br>
42. 单机版的redis在切换为集群之后，数据是怎么转移的<br>
https://www.cnblogs.com/blazeZzz/p/11007977.html<br>
43. hashMap为什么使用红黑树?<br>
https://blog.csdn.net/varyall/article/details/80509922<br>
https://blog.csdn.net/qq_41999455/article/details/95342982<br>
44. 序列化底层原理<br>
https://blog.csdn.net/weixin_39723544/article/details/80527550<br>
45. final具体使用场景<br>
你自己定义了一些策略，这个策略在内部做了一个继承结构，你不希望别人去改变你的策略，这个时候就可以用final。
46. CopyOnWriteList存在的问题？<br>
https://www.jianshu.com/p/5f570d2f81a2<br>
47. 创建线程的四种方式<br>
https://blog.csdn.net/m0_37840000/article/details/79756932<br>
48. 如何实现mysql事务？<br>
https://blog.csdn.net/weixin_44337261/article/details/103982389<br>
49. 怎么确保一个集合不能被修改<br>
https://blog.csdn.net/qq_38882813/article/details/88981109<br>
50. 301和302的区别<br>
https://blog.csdn.net/liouswll/article/details/81288601<br>
51. 307状态码？<br>
https://blog.csdn.net/idwtwt/article/details/90692773<br>
https://zhangzifan.com/http-307-code.html<br>
52. G1和CMS的优缺点<br>
https://blog.csdn.net/hello_word2/article/details/105004525<br>
53. 服务器存储空间快满了（95%），还有一个小时存储就满了，在不影响服务正常运行的情况下，该如何解决？<br>
df -h，先看看磁盘使用的情况<br>
然后就是到你的系统部署的地方，一般就是tomcat下的日志、spring boot的日志，去看看，如果过多，就删除掉一些日志就行了，自己注意让tomcat或者nginx之类的日志输出，按天切割，这样你还可以写个shell脚本，crontab定时，定期删除7天以前的日志<br>
要是不行，那就：find / -size +100M |xargs ls -lh，找找大于100m的文件，但是如果有大量的小文件，那么这样是不行的<br>
或者是用：du -h >fs_du.log，看看各个目录占用的磁盘空间大小，看看是不是哪个目录有大量的小文件<br>
54. spring bean的三种装备方式?<br>
https://blog.csdn.net/weixin_42453837/article/details/85328686<br>
55. java stream流和lamda表达式<br>
56. fork/join<br>
57. redis为什么使用调表?<br>
https://www.cnblogs.com/Elliott-Su-Faith-change-our-life/p/7545940.html<br>
58. 拦截器和过滤器的区别?<br>
https://www.jianshu.com/p/7bd0cad17f23<br>
59. 快速排序的优化<br>
https://blog.csdn.net/qq_19525389/article/details/81436838<br>
