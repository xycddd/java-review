1. 为什么AQS使用的是双向队列?使用AQS实现可重入锁？<br>
队列中的线程被取消之后被设置成空值，所以队列中遇到空值并不一定代表到达了队列的末尾，使用双向链表可以进行双重检查,从前向后扫描一次
，然后从后向前扫描一次，快速判断当前这个请求是否还在同步队列中<br>
https://blog.csdn.net/zhang5476499/article/details/83796289
2. hashmap使用什么方法解决冲突？使用头插法还是尾插法？头插有什么问题？那为什么还要在1.7的时候使用头插法？为什么头插换成尾插？
hashMap在jdK1.8之前采用的头插法，1.8版本以及之后的版本采用的是尾插法<br>
使用头插法在高并发场景下会造成链表成环的问题<br>
解决死循环是一个点还有一个点就是 当时1.7时候用头插是考虑到了一个所谓的热点数据的点(新插入的数据可能会更早用到)，但这其实是个伪命题,y因为JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置(就是因为头插) 所以最后的结果 还是打乱了插入的顺序 所以总的来看支撑1.7使用头插的这点原因也不足以支撑下去了 所以就干脆换成尾插 一举多得<br>
来自https://blog.csdn.net/qq_33256688/article/details/79938886
4. https://www.cnblogs.com/gxyandwmm/p/9495923.html
5. spring如何实现单例模式，哪些情况下会用到多例？
spring的三级缓存，实际上就是放到一个map中，用的时候去map中去取，有的话就取出来，没有就创建<br>
个人只在spring和struct2整合的时候用到多例
6. spring如何实现循环依赖?
Spring中有三级缓存<br>
singletonObjects 用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用 <br>
earlySingletonObjects 存放原始的 bean 对象（尚未填充属性），用于解决循环依赖 <br>
singletonFactories 存放 bean 工厂对象，用于解决循环依赖<br>

Spring的单例对象的初始化主要分为三步：<br>
（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象<br>
（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充<br>
（3）initializeBean：调用spring xml中的init 方法。<br>

实例化对象A的步骤，<br>
第一步，实例化，把自己添加到singletonFactories <br>
第二步，填充属性的时候发现需要B的引用，转而就是实例化B<br>

当实例化对象B的时候。调用对象的构造方法实例化对象，<br>
其次，填充属性，由于A把自己的引用添加到了singletonFactories (暴露给外部)，所以B直接拿到了A的引用，同时singletonFactories 将A的这个引用删除，添加到earlySingletonObjects 中，<br>
然后B调用init方法初始化自己。<br>

当B初始化完成之后，A填充关于B的属性，然后init，循环依赖决绝。因为B里面拿到的是A的引用，所以A初始化完成之后，B里面关于A的对象的填充也完成了。<br>
7. 为什么无法解决构造器循环依赖
因为在第一步实例化的时候需要调用构造器方法，加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决<br>
8. TCP报文段结构<br>
https://www.cnblogs.com/feng9exe/p/8058891.html<br>
9. Java中什么样的对象才能作为gc root，gc roots有哪些<br>
https://blog.csdn.net/yulidrff/article/details/85330045
10. mysql中的一些参数
```
<!--    连接池启动时的初始值 -->
<property name="initialSize" value="${initialSize}" />
<!--  连接池的最大值 -->
<property name="maxActive" value="${maxActive}"/>
<!-- 最大空闲值.当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 -->
<property name="maxIdle" value="${maxIdle}"/>
<!--   最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 -->
```
11. 进程调度算法<br>
https://www.cnblogs.com/szitcast/p/10927375.html<br>
https://blog.csdn.net/zh13487/article/details/83928284<br>
12. HTTP报文结构<br>
13. 什么时候使用聚簇索引？什么时候使用非聚簇索引？为什么频繁被修改的列使用非聚簇索引？
https://blog.csdn.net/qq_35956041/article/details/81017995<br>
最通俗的解释是:聚簇索引的顺序就是数据的物理存储顺序，而对非聚簇索引的索引顺序与数据物理排列顺序无关。举例来说，你翻到新华字典的汉字“爬”那一页就是P开头的部分，这就是物理存储顺序（聚簇索引）；而不用你到目录，找到汉字“爬”所在的页码，然后根据页码找到这个字（非聚簇索引
14. springboot自动配置原理<br>
https://blog.csdn.net/u014745069/article/details/83820511<br>
15. react和Vue的区别<br>
https://www.jianshu.com/p/b7cd52868e95?from=groupmessage
16. await/async和Promise的区别<br>
简洁<br>
try/catch能够处理同步和异步的错误，promise的try/catch不能需要.catch
避免深层的嵌套<br>
17. linux的五种IO模型<br>
https://www.jianshu.com/p/e4768446f7eb<br>
https://blog.csdn.net/historyasamirror/article/details/5778378<br>
https://www.cnblogs.com/cyanjng/p/9828092.html<br>
18. 超线程和多线程的区别<br>
https://blog.csdn.net/cheng__lu/article/details/98884263<br>
20. 守护线程和用户线程的区别<br>
https://blog.csdn.net/weixin_39935887/article/details/80623769<br>
21. 缓存一致性协议<br>
https://www.cnblogs.com/yjf512/p/5166415.html
22. CPU二级缓存为什么要这样设计？<br>
CPU的局部性原理<br>
23. Tomcat 类加载器之为何违背双亲委派模型？<br>
https://blog.csdn.net/qq_38182963/article/details/78660779<br>
24. Tom的消息处理过程<br>
https://www.cnblogs.com/haimishasha/p/10744696.html<br>
https://www.cnblogs.com/haimishasha/p/10747901.html<br>

