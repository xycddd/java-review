
#### 题目：有多少种解密方式（解码方法）
#### 算法解析
**方法一：动态规划**<br>
建立一位dp数组，长度比输入数组长多多2，全部初始化为1，因为斐波那契数列的前两项也为1，然后从第三个数开始更新，对应数组的第一个数。对每个数组首先判断其是否为0，若是将改为dp赋0，若不是，赋上一个dp值，此时相当如加上了dp[i - 1], 然后看数组前一位是否存在，如果存在且满足前一位不是0，且和当前为一起组成的两位数不大于26，则当前dp值加上dp[i - 2], 至此可以看出来跟斐波那契数组的递推式一样
```
class Solution {
public:
    int numDecodings(string s) {
        if(s.empty() || (s.size()>1 && s[0]=='0'))
            return 0;
        vector<int> dp(s.size()+1,0);
        dp[0]=1;
        for(int i=1;i<dp.size();i++){
            if(s[i-1]!='0')
                dp[i]+=dp[i-1];
            if(i>=2 && s.substr(i-2,2)<="26" && s.substr(i-2,2)>="10"){
                dp[i]+=dp[i-2];
            }
        }
        return dp.back();
    }
};
```
**方法二**<br>
我们用两个变量c1, c2来分别表示s[i-1]和s[i-2]的解码方法，然后我们从i=1开始遍历，也就是字符串的第二个字符，我们判断如果当前字符为'0'，说明当前字符不能单独拆分出来，只能和前一个字符一起，我们先将c1赋为0，然后我们看前面的字符，如果前面的字符是1或者2时，我们就可以更新c1 = c1 + c2，然后c2 = c1 - c2，其实c2赋值为之前的c1，如果不满足这些条件的话，那么c2 = c1
```
class Solution {
public:
    int numDecodings(string s) {
        if (s.empty() || s.front() == '0') return 0;
        int c1 = 1, c2 = 1;
        for (int i = 1; i < s.size(); ++i) {
            if (s[i] == '0') c1 = 0;
            if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6')) {
                c1 = c1 + c2;
                c2 = c1 - c2;
            } else {
                c2 = c1;
            }
        }
        return c1;
    }
};
```
