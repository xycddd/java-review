#### 题目：第K大的数

**线性时间选择**算法,描述如下:
1. if (n<75) 排序后取第 k 个数;   // 该步耗时 O(1)
2. 将输入的序列分成 g=n/5 个组,将每组的中位数存入数组 B; // 该步耗时 O(n)
3. 递归地,求 B 的中位数 X;      // 该步耗时 T(n/5)
4. 把输入序列中小于 X 的放入集合C,大于等于 X 的放入集合 D;
5. if (k<=|C|) 递归地在 C 中找第 k 个元;
       else 递归地在 D 中找第 k-|C| 小元;  // 该步耗时 T(0.75n)

总时间耗费 T(n)=T(0.2n)+T(0.75n)+O(n)=O(n)

#### 算法解析
解法一：基于快速排序的算法
随机地从数组中选择一个数作为pivot，将小于pivot的数移动pivot之前，大于pivot的数移动到pivot之后，寻找第K大的数就是找第n-k个小的数，所以当进行一次划分
之后，如果
1. mid==n-k，那么nums[n-k]就是第K大的数
2. mid<n-k, 那么第k大的数在右半数组，而且仍然是第k大数
3. mid>n-k，那么第k大的数在左半数组，且在左半数组中是第k-(n-mid)大的数
```
void swap(int *nums,int i,int j){
    int temp=nums[i];
    nums[i]=nums[j];
    nums[j]=temp;
}

int partion(int *num, int n)
{
    int idx = rand() % n;
    swap(num,idx, n - 1);
    int i = -1;    //i表示最后一个小于num[n-1]的元素的位置
    int j = 0;     
    for (j = 0; j<n; j++)
    {
        //将小于num[n-1]的数交换到前半部分
        if (num[j]<num[n - 1])
        {
            swap(num,++i, j);
        }
    }
    swap(num,++i, n - 1);
    return i;
}
int findKthLargest(int* nums, int numsSize, int k)
{
    int mid;
    if (k <= 0)
        return -1;
    if (numsSize<k)
        return -1;
    mid = partion(nums, numsSize);   //对原数组进行一次划分
    if (mid == numsSize - k)      //如果mid==n-k，那么返回该值，这就是第k大的数
        return nums[mid];
    else if (mid<numsSize - k)
        return findKthLargest(nums + mid + 1, numsSize - mid - 1, k);  //如果mid<n-k，那么第k大的数在右半数组，而且仍然是第k大数
    else
        return findKthLargest(nums, mid, k - (numsSize - mid));   //如果mid>n-k，那么第k大的数在左半数组，且在左半数组中是第k-(n-mid)大的数
}
```
